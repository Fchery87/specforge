import JSZip from "jszip";

export interface ZipEntry {
  path: string;
  content: string;
}

export interface ZipFolder {
  path: string;
  files: ZipEntry[];
  subfolders?: ZipFolder[];
}

export async function createZipWithStructure(
  entries: ZipEntry[],
  rootFolder = "project"
): Promise<Uint8Array> {
  const zip = new JSZip();
  
  // Create root folder
  const root = zip.folder(rootFolder);
  
  if (!root) {
    throw new Error("Failed to create root folder in ZIP");
  }

  for (const entry of entries) {
    const pathParts = entry.path.split("/");
    let currentFolder = root;

    // Navigate to the correct folder
    for (let i = 0; i < pathParts.length - 1; i++) {
      const folderName = pathParts[i];
      const existingFolder = currentFolder.folder(folderName);
      if (existingFolder) {
        currentFolder = existingFolder;
      } else {
        currentFolder = currentFolder.folder(folderName)!;
      }
    }

    // Add the file to the current folder
    currentFolder.file(pathParts[pathParts.length - 1], entry.content);
  }

  return await zip.generateAsync({ type: "uint8array" });
}

export async function createZip(entries: ZipEntry[]): Promise<Uint8Array> {
  const zip = new JSZip();
  
  for (const entry of entries) {
    zip.file(entry.path, entry.content);
  }

  return await zip.generateAsync({ type: "uint8array" });
}

export function createHandoffStructure(
  projectTitle: string,
  artifacts: Array<{ phaseId: string; title: string; content: string }>,
  masterPrompt?: string
): ZipFolder {
  const rootFolder = slugify(projectTitle);
  
  const folders: ZipFolder[] = [];
  
  // Group artifacts by phase
  const phaseGroups = artifacts.reduce((acc, artifact) => {
    if (!acc[artifact.phaseId]) {
      acc[artifact.phaseId] = [];
    }
    acc[artifact.phaseId].push(artifact);
    return acc;
  }, {} as Record<string, typeof artifacts>);

  // Create folders for each phase
  for (const [phaseId, phaseArtifacts] of Object.entries(phaseGroups)) {
    const folder: ZipFolder = {
      path: `${rootFolder}/${phaseId}`,
      files: phaseArtifacts.map((a) => ({
        path: `${phaseId}/${slugify(a.title)}.md`,
        content: a.content,
      })),
    };
    folders.push(folder);
  }

  // Add handoff folder with master prompt
  folders.push({
    path: `${rootFolder}/handoff`,
    files: [
      {
        path: `handoff/README.md`,
        content: createReadmeContent(projectTitle, artifacts, masterPrompt),
      },
    ],
  });

  if (masterPrompt) {
    folders.push({
      path: `${rootFolder}/handoff`,
      files: [
        {
          path: `handoff/MASTER_PROMPT.md`,
          content: masterPrompt,
        },
      ],
    });
  }

  return {
    path: rootFolder,
    files: [],
    subfolders: folders,
  };
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, "")
    .replace(/[\s_-]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function createReadmeContent(
  projectTitle: string,
  artifacts: Array<{ phaseId: string; title: string; content: string }>,
  masterPrompt?: string
): string {
  const phases = [...new Set(artifacts.map((a) => a.phaseId))];
  
  let content = `# ${projectTitle}\n\n`;
  content += `Generated by SpecForge\n\n`;
  content += `## Project Structure\n\n`;
  
  for (const phase of phases) {
    content += `### ${phase}\n`;
    const phaseArtifacts = artifacts.filter((a) => a.phaseId === phase);
    for (const artifact of phaseArtifacts) {
      content += `- ${artifact.title}\n`;
    }
    content += "\n";
  }

  if (masterPrompt) {
    content += `\n## Master Prompt\n\n`;
    content += `See MASTER_PROMPT.md for the complete prompt used to generate this project.\n`;
  }

  content += `\n## Generated Phases\n\n`;
  content += phases.map((p) => `- ${p}`).join("\n");

  return content;
}

export async function zipFolderToUint8Array(folder: ZipFolder): Promise<Uint8Array> {
  const zip = new JSZip();
  
  const addFolderToZip = (currentFolder: JSZip, folder: ZipFolder) => {
    // Add files in this folder
    for (const file of folder.files) {
      currentFolder.file(file.path, file.content);
    }

    // Add subfolders
    if (folder.subfolders) {
      for (const subfolder of folder.subfolders) {
        const newFolder = currentFolder.folder(subfolder.path.split("/").pop()!);
        if (newFolder) {
          addFolderToZip(newFolder, subfolder);
        }
      }
    }
  };

  const root = zip.folder(folder.path.split("/").pop()!);
  if (root) {
    addFolderToZip(root, folder);
  }

  return await zip.generateAsync({ type: "uint8array" });
}
